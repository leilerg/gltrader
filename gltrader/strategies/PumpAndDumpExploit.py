import os

from gltrader.strategy import Strategy
from gltrader.action import *


import logging
os.environ['LOG_FILE'] = os.path.dirname(os.path.abspath(__file__)) + '/../../gltrader.log'
log = logging.getLogger("strategiesLog")
  
log.setLevel(logging.DEBUG)
  
# Create handlers
# File handler
fh = logging.FileHandler(os.environ["LOG_FILE"])
fh.setLevel(logging.DEBUG)
# Console handler
ch = logging.StreamHandler()
ch.setLevel(logging.INFO)
# Formatter, to be added to the file handler
formatter = logging.Formatter("%(levelname)s - %(asctime)s - %(name)s: %(message)s")
fh.setFormatter(formatter)
ch.setFormatter(formatter)
  
# Add handler to logger
log.addHandler(fh)
log.addHandler(ch)

from threading import currentThread

import builtins
import datetime
import statistics



class PumpAndDumpExploit(Strategy):
    #===========================================================================
    # Executes a "TradeUp" action if the 24 hr trailing volume change reaches a certain threshold
    # 
    # :returns: (Action) The MinTradeUp Action, 
    # which executes 2 trades and returns a tuple (Order1, Order2) when its "do" method is called
    #===========================================================================

    # MUST override strategy name!
    strName = "PumpAndDumpExploit"

    def printLogHeader(self):
        #==============================================================
        # Prints the log header, to monitor for the relevant quantities
        # Every strategy MUST have this!!
        #==============================================================
        log.debug(self.strName + " - Debug dump")
        log.debug("{0:6}".format("Market") +
                  "{0:>13}".format("BaseVol Mean") + 
                  "{0:>14}".format("BaseVol Stdev") + 
                  "{0:>13}".format("Curr BaseVol") + 
                  "{0:>11}".format("Vol - Mean") +
                  "{0:>11}".format("Last Price") +
                  "{0:>11}".format("Curr Open") +
                  "{0:>11}".format("Last Close") +
                  "{0:>11}".format("24hr High"))
        return None 

    
    def run(self):
        # Log volumes...
        if self.market.avgVolPerHourPreviousDay() != 0:
            log.debug("{:>6}".format(self.market.name) + 
                      "{:13.4f}".format(self.market.previousDayTickBsVolMean()) +
                      "{:14.4f}".format(self.market.previousDayTickBsVolStdev()) +
                      "{:13.4f}".format(self.market.currentBaseVol()) +
                      "{:11.4f}".format((self.market.currentBaseVol() \
                                        -self.market.previousDayTickBsVolMean()) \
                                        /self.market.previousDayTickBsVolStdev()) + 
                      "{:11.8f}".format(self.market.last()) + 
                      "{:11.8f}".format(self.market.currentOpen()) + 
                      "{:11.8f}".format(self.market.previousDayLastClose()) + 
                      "{:11.8f}".format(self.market.previousDayHigh(includeCurrent=False)))
        else:
            log.debug("WARNING: Daily average volume is: " + str(self.market.avgVolPerHourPreviousDay()) +
                      "for market " + self.market.name + ", in thread " + str(currentThread().ident))


        # Default - Do not execute trade 
        executeTrade = False
        # Flag - Recent volume increase
        actionDetected = False
        # Flag - Is it a pump?
        pumpDetected = False
        
        

        # Check if there's increased market action
        actionDetected = self.actionDetected()
        # if self.market.volumeLastHr() > 10*self.market.avgVolPerHourPreviousDay():
        #     actionDetected = True
            
        # Check there's an actual price pump, not dump
        if self.market.last() > self.market.previousDayLastClose() and \
           self.market.last() > self.market.currentOpen() and \
           self.market.last() > self.market.previousDayHigh(includeCurrent = False):
            pumpDetected = True
            
            
        # All checks complete - Set the final flag
        executeTrade = actionDetected and pumpDetected and self.canTrade()


        #=======================================================================
        # if self.market.name == "LTC":
        #     executeTrade = True and self.market.canTrade()
        #=======================================================================



        if executeTrade:
            # Log trade execution
            log.info("Market: {:>5}".format(self.market.name)  + 
                    " - PUMP 'n' DUMP detected - EXECUTING TRADE!")
            
            # Take the appropriate action
            actionResult = PumpAndDumpExploitTrade(self.market)
            
            return actionResult




    def canTrade(self):
        #=======================================================================
        # enforces two conditions:
        #    1:   The last trade was executed at least 24hrs ago
        #         (Avoids wash trades on the same signal)
        #    2:   The market has been monitored for at least one hour
        #         (Avoids catching the late action in the pump because the market
        #          is so low volume that only the late part of the pump brings it
        #          over the volume detection threshold. Also avoids a market 
        #          dropping out of monitoring shortly after the pump, then back in
        #          and trade again on the same signal.)
        #
        # :returns: Bool, if market can be traded or not 
        #=======================================================================
        _canTrade = False
        timeNow = datetime.datetime.now()
        # Get total seconds elapsed since last trade
        lastTradeTimeDeltaSeconds = (timeNow - self.market.lastTradeTime(self.strName)).total_seconds()
        log.debug("Strategy: " + self.strName + ", Seconds elapsed since last trade: "
                             + str(lastTradeTimeDeltaSeconds))
        # If more than one day, good to go
        if lastTradeTimeDeltaSeconds > 86400:
            _canTrade = True
        return _canTrade


    def actionDetected(self):
        # Initialize as True, condition checking will set it as False immediately
        _actionDetected = True
        # Two conditions are enforced
        # One - Volume in last two ticks must be below threshold
        prevDayBaseVolumes = self.market.getAllPreviousDayBaseVolumes()
        dblVolThreshold = self.market.previousDayTickBsVolMean() + \
                          self.config["vol_hi_bound_stdev"] * self.market.previousDayTickBsVolStdev()
        for baseVolume in prevDayBaseVolumes[-2:-1]:
            _actionDetected = _actionDetected and baseVolume < dblVolThreshold

        # Two - the last hour volume must exceed the volatility threshold
        dblVolThreshold = self.market.previousDayTickBsVolMean() + \
                          self.config["vol_pump_stdev"] * self.market.previousDayTickBsVolStdev()
        _actionDetected = _actionDetected and \
                          self.market.currentBaseVol() > dblVolThreshold
        
        # prevDayVolumes = self.market.getAllPreviousDayVolumes()
        # dblVolThreshold = self.market.previousDayTickVolMean() + \
        #                   self.config["vol_hi_bound_stdev"] * self.market.previousDayTickVolStdev()
        # for volume in prevDayVolumes[-2:-1]:
        #     _actionDetected = _actionDetected and volume < dblVolThreshold

        # # Two - the last hour volume must exceed the volatility threshold
        # dblVolThreshold = self.market.previousDayTickVolMean() + \
        #                   self.config["vol_pump_stdev"] * self.market.previousDayTickVolStdev()
        # _actionDetected = _actionDetected and \
        #                   self.market.currentVol() > dblVolThreshold

        return _actionDetected
